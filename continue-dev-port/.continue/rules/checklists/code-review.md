---
name: Code Review Checklist
description: Specialized review criteria for AI-generated code. Covers correctness, security, edge cases, error handling, performance, code quality, dependencies, testing, documentation, and design patterns.
alwaysApply: false
---

# AI-Generated Code Review Criteria

**Purpose:** Specialized review criteria for code generated by AI coding assistants.

**Key Insight:** AI-generated code requires **different review focus** than human-written code. AI excels at patterns but struggles with edge cases, security, and business logic nuances.

---

## Quick Reference: AI Code Weaknesses

| Weakness | Frequency | Review Priority |
|----------|-----------|-----------------|
| Missing edge cases | Very High | Critical |
| Over-optimistic error handling | High | Critical |
| Security vulnerabilities (OWASP) | High (45%) | Critical |
| Inefficient algorithms | Medium | High |
| Poor testability | Medium | High |
| Hallucinated APIs/libraries | Low | Critical |
| Over-engineering | Medium | Medium |

---

## 1. Correctness Review

### Does it actually solve the problem?

- [ ] **Requirements match:** Code implements all acceptance criteria from plan
- [ ] **No hallucinated solutions:** AI didn't invent features that don't exist
- [ ] **Business logic correct:** Edge cases from domain knowledge handled
- [ ] **No silent failures:** Errors aren't swallowed without handling
- [ ] **Return values correct:** Functions return expected types and values

### Common AI Correctness Failures

**Example: AI often confuses similar APIs**
```javascript
// AI might write (WRONG - hallucinated method):
array.removeAt(index)

// Should be:
array.splice(index, 1)
```

**Example: AI misses business rules**
```python
# AI might write:
if price > 0:
    apply_discount(price)

# Should account for business rule:
if price > 0 and user.is_eligible_for_discount() and discount.is_active():
    apply_discount(price)
```

---

## 2. Security Review (MANDATORY HUMAN REVIEW)

**CRITICAL:** Any code touching these areas MUST be reviewed by a human with security experience:

- [ ] **Authentication/Authorization logic**
- [ ] **Data handling** (PII, financial, health)
- [ ] **External API integrations**
- [ ] **File uploads**
- [ ] **Database queries with user input**
- [ ] **Command execution**
- [ ] **Cryptography/hashing**

**Red flags:**
- `eval()`, `exec()`, `subprocess.call()` with user input
- String concatenation in SQL queries
- User input in HTML without escaping
- Hardcoded secrets or API keys
- Insufficient input validation

---

## 3. Edge Cases & Boundary Conditions

AI systematically misses edge cases. Test these:

### Null/Undefined/None Handling
- [ ] **Null inputs:** What if parameter is `null`/`None`/`undefined`?
- [ ] **Empty inputs:** Empty string `""`, empty array `[]`, empty object `{}`
- [ ] **Optional parameters:** Function works when optional params omitted

### Boundary Values
- [ ] **Zero:** Division by zero handled
- [ ] **Negative numbers:** Algorithms work with negative inputs if applicable
- [ ] **Maximum values:** Large numbers don't cause overflow
- [ ] **Minimum values:** Small/negative numbers handled
- [ ] **Off-by-one errors:** Array indexing correct (0-indexed vs 1-indexed)

### Data Structure Limits
- [ ] **Empty collections:** Loops/operations work on empty arrays/lists
- [ ] **Single-item collections:** Edge case for length = 1
- [ ] **Very large collections:** Performance acceptable with 10k+ items
- [ ] **Duplicate values:** Handles duplicates correctly if applicable

### String/Text Edge Cases
- [ ] **Unicode/emoji:** Non-ASCII characters handled
- [ ] **Very long strings:** 1000+ character strings don't break UI
- [ ] **Special characters:** Quotes, apostrophes, newlines handled

### Date/Time Edge Cases
- [ ] **Timezones:** UTC vs local time handled correctly
- [ ] **DST transitions:** Daylight saving time changes accounted for
- [ ] **Leap years:** February 29th handled
- [ ] **Past/future dates:** No assumption about date ranges

---

## 4. Error Handling & Resilience

AI tends to be overly optimistic. Review:

### Try/Catch Coverage
- [ ] **External calls wrapped:** API calls, DB queries, file I/O in try/catch
- [ ] **Specific exceptions caught:** Not catching generic `Exception`, but specific types
- [ ] **Exceptions don't leak data:** Error messages don't expose secrets/internals
- [ ] **Graceful degradation:** App continues functioning (degraded mode) when possible

### Error Scenarios Tested
- [ ] **Network failures:** Timeout, connection refused, DNS failure
- [ ] **API errors:** 4xx, 5xx responses handled
- [ ] **Database errors:** Connection lost, query timeout, constraint violation
- [ ] **File system errors:** Disk full, permission denied, file not found
- [ ] **Third-party service down:** Circuit breaker or fallback exists

### Validation
- [ ] **Input validation exists:** User input validated before use
- [ ] **Validation errors user-friendly:** Clear messages, not technical jargon
- [ ] **Server-side validation:** Never trust client-side only

---

## 5. Performance & Efficiency

AI often chooses inefficient approaches. Review:

### Algorithm Complexity
- [ ] **Big O analyzed:** Is this O(n^2) when O(n) exists?
- [ ] **Nested loops reviewed:** Can inner loops be eliminated?
- [ ] **Database N+1 queries avoided:** Batch queries or use joins
- [ ] **Unnecessary iterations:** Not looping multiple times over same data

### Common Performance Issues
```javascript
// AI might write (O(n^2)):
for (let user of users) {
    for (let order of orders) {
        if (order.userId === user.id) { /* ... */ }
    }
}

// Better (O(n)):
const ordersByUser = _.groupBy(orders, 'userId')
for (let user of users) {
    const userOrders = ordersByUser[user.id] || []
}
```

### Resource Usage
- [ ] **Memory leaks prevented:** Event listeners cleaned up, intervals cleared
- [ ] **Connection pools used:** Database/API connections pooled
- [ ] **Caching implemented:** Expensive operations cached when appropriate
- [ ] **Pagination exists:** Large datasets paginated, not loaded all at once

---

## 6. Code Quality & Maintainability

### Readability
- [ ] **Variable names clear:** `user` not `u`, `totalPrice` not `tp`
- [ ] **Function names descriptive:** Name describes what it does
- [ ] **Magic numbers eliminated:** Constants with names, not bare numbers
- [ ] **Comments explain WHY:** Not what (code shows what), but why this approach
- [ ] **Complex logic has comments:** Non-obvious algorithms explained

### Structure
- [ ] **Single Responsibility Principle:** Each function does one thing
- [ ] **DRY (Don't Repeat Yourself):** No copy-pasted code blocks
- [ ] **Functions are small:** <50 lines ideal, <100 max
- [ ] **Deep nesting avoided:** Max 3 levels of indentation

### Testability
- [ ] **Pure functions preferred:** Same input -> same output, no side effects
- [ ] **Dependencies injectable:** Database, API clients passed as parameters
- [ ] **Side effects isolated:** I/O separated from business logic
- [ ] **Functions have clear contracts:** Input/output types clear

---

## 7. Dependencies & Imports

AI sometimes adds unnecessary dependencies.

### Dependency Review
- [ ] **Actually needed:** Can we solve this without a new package?
- [ ] **Actively maintained:** Last commit within 12 months
- [ ] **Reasonable size:** Not adding 5MB for a 10-line utility
- [ ] **Well-established:** 1000+ stars or widely used in industry
- [ ] **Security record clean:** No recent CVEs
- [ ] **License compatible:** MIT, Apache, BSD (check with legal if GPL/AGPL)
- [ ] **Alternatives considered:** Is there a lighter/better option?

### Import Cleanliness
- [ ] **No unused imports:** Dead imports removed
- [ ] **Specific imports:** `from x import y` not `import *`
- [ ] **Circular dependencies avoided:** No A imports B imports A

---

## 8. Testing

### Test Coverage
- [ ] **Unit tests exist:** New functions have unit tests
- [ ] **Happy path tested:** Normal use case works
- [ ] **Error cases tested:** At least 2 error scenarios tested
- [ ] **Edge cases tested:** Null, empty, boundary values (see section 3)
- [ ] **Integration tests for APIs:** Endpoints tested end-to-end
- [ ] **Mocks used appropriately:** External services mocked in tests

### Test Quality
- [ ] **Tests are independent:** Can run in any order
- [ ] **Tests are deterministic:** No flaky tests, same result every time
- [ ] **Assertions are specific:** Not just `assert result`, but `assert result == expected`
- [ ] **Test names descriptive:** `test_user_login_fails_with_wrong_password()`

---

## 9. Documentation

### Code Documentation
- [ ] **Public APIs documented:** Function signatures, parameters, return values
- [ ] **Complex algorithms explained:** Why this approach, what it does
- [ ] **TODOs tracked:** Any `// TODO` items in issue tracker
- [ ] **Breaking changes noted:** If API changed, migration guide exists

### User-Facing Documentation
- [ ] **API endpoints documented:** OpenAPI/Swagger spec updated
- [ ] **README updated:** New features added to README
- [ ] **Changelog updated:** Version history reflects changes

---

## 10. Framework & Project Conventions

### Consistency
- [ ] **Follows project style:** Matches existing code patterns
- [ ] **Uses project utilities:** Leverages shared helpers (e.g., logging, auth)
- [ ] **File structure correct:** New files in appropriate directories
- [ ] **Naming conventions:** CamelCase/snake_case/kebab-case matches project

### Framework Best Practices
- [ ] **React:** Hooks used correctly, no direct DOM manipulation
- [ ] **Django:** ORM used, not raw SQL; class-based views follow patterns
- [ ] **Express:** Middleware used appropriately, async errors caught
- [ ] **[Your Framework]:** Add project-specific checks here

---

## 11. AI-Specific Red Flags

Watch for these AI hallucination patterns:

### Hallucinated Code
- [ ] **APIs don't exist:** AI invented methods that don't exist in the language/framework version
- [ ] **Methods are real:** Check docs if unfamiliar method
- [ ] **Imports are valid:** Package actually exports what's imported

### Over-Engineering
- [ ] **Complexity justified:** Is this added abstraction necessary?
- [ ] **YAGNI respected:** "You Ain't Gonna Need It" - no premature optimization
- [ ] **Simple solution preferred:** If 5 lines solve it, don't write 50

### Inconsistent Patterns
- [ ] **Mixed paradigms:** Not mixing promises and callbacks
- [ ] **Mixed styles:** Consistent async/await vs .then()
- [ ] **Mixed data structures:** Consistent choice of Map vs Object

---

## 12. Design Patterns & Architecture

AI often chooses suboptimal architectural patterns or over-engineers solutions.

### SOLID Principles

- [ ] **Single Responsibility:** Each class/module has one clear purpose
- [ ] **Open/Closed:** Can extend behavior without modifying existing code
- [ ] **Liskov Substitution:** Subclasses don't break base class contracts
- [ ] **Interface Segregation:** Interfaces are focused, not bloated
- [ ] **Dependency Inversion:** High-level code doesn't depend on low-level details

### Anti-Patterns to Avoid

- [ ] **God Object:** No single class/file doing everything
- [ ] **Spaghetti Code:** Control flow is clear, not tangled
- [ ] **Copy-Paste Programming:** Duplication extracted to shared functions
- [ ] **Premature Optimization:** Code is simple first, optimized only when needed
- [ ] **Golden Hammer:** Not forcing one pattern/library everywhere
- [ ] **Magic Strings:** No repeated literal strings, use constants
- [ ] **Tight Coupling:** Modules can be changed independently

### Composition Over Inheritance

- [ ] **Favor composition:** Uses composition unless inheritance clearly fits
- [ ] **Shallow hierarchies:** Inheritance depth <= 3 levels
- [ ] **Interface over abstract:** Prefers interfaces to abstract classes (when available)

### Separation of Concerns

- [ ] **Business logic isolated:** Not mixed with UI or data access
- [ ] **Configuration external:** Not hardcoded in business logic (use env vars, config files)
- [ ] **Cross-cutting concerns consistent:** Logging, auth, validation handled uniformly
- [ ] **Layers respected:** Presentation -> Business -> Data (no skipping layers)
- [ ] **Pure functions preferred:** Side effects isolated to boundaries

### When Patterns Are Over-Engineering

- [ ] **Complexity justified:** Pattern solves a real problem, not hypothetical
- [ ] **Team understands it:** Pattern is familiar to team (or documented well)
- [ ] **Future-proofing is minimal:** Solve today's problem, not next year's
- [ ] **Simple alternative considered:** Asked "can we just use a function?"

**Red flags:**
- Abstract factory for 1 concrete type
- Strategy pattern with only 1 strategy
- Repository pattern for read-only data
- Observer pattern for 1 listener

---

## Review Process

### Step 1: Automated Checks
Run these before human review:
```bash
npm run lint          # Code style
npm run test          # All tests pass
npm run type-check    # TypeScript/mypy
npm audit             # Dependency vulnerabilities
```

### Step 2: Code Review Checklist
Use sections 1-12 above. Focus on:
1. **Security** (section 2) - ALWAYS human review
2. **Correctness** (section 1) - Does it work?
3. **Edge Cases** (section 3) - AI's biggest weakness
4. **Error Handling** (section 4) - AI is optimistic
5. **Design Patterns** (section 12) - Architecture and SOLID principles

### Step 3: Test the Code
- [ ] **Run locally:** Actually execute the code
- [ ] **Test edge cases:** Try null, empty, large inputs
- [ ] **Break it:** Try to make it fail
- [ ] **Performance test:** If performance-critical, benchmark

### Step 4: Approval
Only approve if:
- All critical items checked
- Security review passed (if applicable)
- Tests pass
- You personally understand the code

---

## Approval Levels

| Level | Requirement |
|-------|-------------|
| **Auto-approve** | Trivial changes (typos, comments, formatting) |
| **Standard Review** | Most features, bug fixes (30 min review) |
| **Senior Review** | Auth, payments, security-sensitive (1+ hour) |
| **Architecture Review** | Major refactors, new patterns (team discussion) |

---

**Remember:** The goal isn't to nitpick AI code, but to catch the systematic blind spots AI has. Focus review time on security, edge cases, and business logic correctness.
